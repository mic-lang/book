# 所有権

Micでは、変数があるアドレスの所有権を持っていると、そのアドレスが値を読み書きすることができます。
どの変数も最初は自分自身の変数のアドレスに対して所有権を持っていますが、それがほかのポインタ変数に代入されると今度はそのポインタ変数が、その変数のアドレスに対して所有権を持ちます。
アドレスの所有権は、そのアドレスをほかの変数に代入することによって所有権をその変数に移すことができます。
所有権を持っていた変数は、ほかの変数が自身のアドレスの所有権を持っているので、この代入操作以降、その変数を通じて、そのアドレスが指し示している値の読み書きができなくなります。

基本的には、Micの所有権システムは次の三原則からなります。

- どの変数もその変数自身のアドレスを最初は持っている。
- ある変数`x`が持っているアドレスをほかの可変ポインタ型変数`y`に渡すと、変数`y`に変数`x`が持っていたアドレスの所有権が移る。また、変数`y`の寿命が切れたら自動的に変数`x`に所有権が戻る。
- ある変数が所有権を持っている任意のアドレスは、ある可変ポインタ型変数に代入されない限りにおいて、任意個の不変ポインタ型変数に代入することができる。

## 可変ポインタ型
可変ポインタ型は、複数の変数で一つのアドレスの所有権を同時に共有することができません。
```c
using p {
    int i = 0;
    int p* x = &i;
    int p* y = &i;//error:i is already moved
}
```
また、ある可変ポインタ型の変数の寿命が切れたら、その変数が所有権を持つ直前までその所有権を持っていた変数に、その変数が持っていた所有権が返されます。

```c
int x = 0;//Firstly, the variable x owns its address &x
using p {
    int p* y = &x;//The ownership of &x is moved here, from x to y
    x = 5;//error: x is moved
}
x = 5;//The ownership of &x returned to x here. Successful!
```

## 不変ポインタ型
不変ポインタ型、いわゆる`const`ポインタ型は、可変ポインタ型とは違い、任意個の変数で一つのアドレスの所有権を同時に共有することができます。ただし、アドレスの中身を変更する権限はありません。
```c
using p {
    int i = 0;
    int p* const x = &i;
    int p* const y = &i;
    int p* const z = &i;
}
```

ただし、可変ポインタ型と不変ポインタ型の変数の間で、データを共有することはできません。
```c
using p {
    int i = 0;
    int p* const x = &i;
    int p* y = &i;//error happened
}
```
